#!/usr/bin/env python3
# coding: utf-8

import os
import sys
import psutil
import libvirt
from docopt import docopt
from subprocess import PIPE
from xml.dom import minidom
from xml.etree.ElementTree import ElementTree


class LabEnvironment(object):  # TODO : Fix flags and input options
    """Labber - CCIE lab deployment tool for QEMU/KVM environments

    Usage:
        labber deploy [-m | --maintain]

    Options:
        -h --help       Show this screen.
        -m --maintain   Maintain previous environment [default: False]
        -s --save       Save the device configuration [default: False]
        --version       Show version.

    """

    def __init__(self, maintain=True, save_conf=False):  # TODO: Reset maintain to false
        # Connect to libvirt. if no connection can be made, sys.exit(1)
        # Other methods depend on the initial connection
        try:
            self.libvirt_conn = libvirt.open('qemu:///system')
        except:
            libvirt.virGetLastError()
            sys.exit(1)

        self.csr_amount = 4
        self.iou_amount = 2
        self.maintain = maintain
        self.save_conf = save_conf
        self.domain_list = self.libvirt_conn.listAllDomains(0)
        self.golden_image_path = r"/home/siem/development/build_tutorial/golden_image.qcow2"  # TODO: make path variable, set image directory in ENV

    def gen_mac_address(self, offset):
        mac_addresses = []
        # If domains exist, get the highest MAC address and use it as a new base MAC
        if len(self.domain_list) != 0:
            for domain in self.domain_list:
                # Convert domain descriptions to XML
                xml_tree = ElementTree.fromstring(domain.XMLDesc(0))
                domain_mac = xml_tree.find('devices/interface/mac').attrib
                domain_mac = int(domain_mac['address'].replace(':', ''), 16)
                mac_addresses.append(domain_mac)
            # Format number as MAC address
            new_base_mac = max(mac_addresses)
            new_mac = new_base_mac + offset
            new_mac = ':'.join(format(s, '02x') for s in bytes.fromhex(new_mac))
            return new_mac
        # If no domains exist, start numbering from 0
        else:
            base_mac = '00000000'
            new_mac = "{:012X}".format(int(base_mac, 16) + offset)
            return new_mac

    def clone(self):
        # Libvirt does not (yet) provide a method to create linked clones
        # but we can use 'qemu-img' to make linked clones from the master
        # image with psutil and subprocess. The downside to this is that
        # the location of the qemu-img binary and the golden_image path
        # become more fixed. Preferably the 'disk' directory should be
        # added to the ENV variables on the host.

        self.csr_amount += 1
        for linked_clone_num in range(1, self.csr_amount):
            clone_disk = psutil.Popen(['/usr/bin/env', 'qemu-img', 'create', '-f', 'qcow2',
                                       '-b', str(self.golden_image_path), 'linked_clone{0}.qcow2'.format(str(linked_clone_num))],
                                      stdout=PIPE)
            clone_disk.wait(timeout=30)

    def deploy_csr(self):
        # Create linked disks
        self.clone()

        # Create libvirt domain definitions from template
        xml_tree = ElementTree()
        dom_xml = xml_tree.parse("domain_template.xml")
        for csr in range(0, self.csr_amount):
            dom_xml.find('.//name').text = 'CSR{0}'.format(csr)
            dom_xml.find('devices/disk/source').attrib['file'] = 'linked_clone{0}.qcow2'.format(csr)
            dom_xml.find('devices/interface/mac').attrib['address'] = self.gen_mac_address(csr)
            # Get next available port, starting at the dynamic port range
            assigned_port = check_tcp_port(49152)
            dom_xml.find('devices/console/source').attrib['file'] = assigned_port
            dom_xml.find('devices/serial/source').attrib['file'] = assigned_port
            # TODO: Set golden image path to ENV variable
            dom_xml = xml_tree.tostring(dom_xml)

            # Deploy CSR domains
            self.libvirt_conn.createXML(dom_xml, 0)  # TODO: Build in error checking, add counter for amount of created domains

    def deploy_iou(self):
        # IOU MAC addresses are generated by the IOU instance and are coupled to the ID number.
        # The base mac is aabb.cc00.0000. ID numbers are added to the second least significant
        # octet. I.e. ID #1 would result in aabb.cc00.0100. Every increment in the ID number
        # increases the MAC address by a decimal 256. This is important for the capture method.
        for iou in iou_amount:
            assigned_port = check_tcp_port(49152)
            # Make sure wrapper-linux is in your $PATH
            psutil.Popen(['/usr/bin/env', 'warpper-linux', '-m', 'BINARY', '-p', # TODO: make binary path variable
                          assigned_port, '--', '-s', serial_amount, '-e', ethernet_amount, iou],
                         stdout=PIPE)

        # Destroy potentially existing domains / IOU nodes
        if not self.maintain:
            self.destroy()

        # Deploy the required nodes
        #if self.csr_amount > 0 and not None:
        #    deploy_csr(self.csr_amount)
        #if self.iou_amount > 0 and not None:
        #    deploy_iou(self.iou_amount)

    def destroy(self):
        # Save the configs if required
        if self.save_conf:
            self.config()

        # Remove CSR instances
        domain_list = self.libvirt_conn.listAllDomains(0)  # TODO: Add counter for the amount of stopped domains
        if len(domain_list) != 0:
            for domain in domain_list:
                # Convert domain descriptions to XML
                raw_xml = domain.XMLDesc(0)
                xml = minidom.parseString(raw_xml)

                # Retrieve attached disks from XML tags
                disk_types = xml.getElementsByTagName('disk')
                disk_nodes = disk_types[0].childNodes
                image_path = disk_nodes[3].attributes['file'].value

                # Stop the domain if it is active and delete the VM definition
                if domain.isActive():
                    domain.destroy()
                domain.undefine()
                # Clean up the disk image
                os.remove(image_path)
                # print("{0} domains have been destroyed.".format(dom_counter))
        else:
            print("No domains defined. Nothing to do.")

        # Remove IOU instances
        proc_counter = 0
        process_name = 'i86bi'  # Killing the IOU node also kills the wrapper
        for proc in psutil.process_iter():
            if process_name in proc.name():
                proc_counter += 1
                proc.kill()
        if proc_counter == 0:
            print("No IOU nodes running. Nothing to do.")
        else:
            print("{0} IOU nodes have been stopped.".format(proc_counter))

    def config(self):
        pass

    def capture(self):
        pass

    def generate_aliases(self):
        pass


def check_tcp_port(tcp_port):
    # Get all currently listening ports
    ports_in_use = []
    for process in psutil.net_connections(kind='tcp4'):
        ports_in_use.append(process.laddr[1])
    # Check whether the desired port is available,
    # if not, increment until next available port starting from base
    for tcp_port in ports_in_use:
        tcp_port += 1
    return tcp_port


if __name__ == '__main__':
    # Create cli menu
    # arguments = docopt(LabEnvironment.__doc__, version='Labber 0.1')
    # print(arguments)
    a = LabEnvironment()
    a.destroy()
    a.clone()
    a.deploy_csr()
